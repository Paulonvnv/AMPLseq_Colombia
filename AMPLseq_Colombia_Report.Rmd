---
title: "AMPLseq Tutorial"
author: "Paulo"
date: "2022-09-27"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
  chunk_output_type: inline
---

The purpose of this tutorial is to introduce researchers at the
laboratory of genomic and evolutionary biology of malaria parasites at
Harvard university in the analysis of genotyping information generated
through amplicon sequencing (also called Microhaplotype genotyping).
This tutorial will cover:

1.  Importing and handling tables in CIGAR format in R environment.

2.  Adding or generating metadata.

3.  Performance of the genotyping process.

4.  Molecular surveillance of drug resistance.

5.  Monitoring transmission intensity.

6.  Measuring geographic connectivity.

In this tutorial we will use a Colombian data set as a example. These
samples comes from a colaboration with the group of Caucaseco, which has
collected samples of *P. falciparum* from 2019 to 2022 in three
municipalities located in the pacific coast of Colombia.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Importing and handling tables in CIGAR format in R environment

Our first step will be to call all required packages in the R
environment:

```{r 'Loading required packages'}

if(!require(adegenet)){
  install.packages("adegenet")
  require(adegenet)
}

if(!require(ade4)){
  install.packages("ade4")
  require(ade4)
}

if(!require(poppr)){
  install.packages("poppr")
  require(poppr)
}

if(!require(dplyr)){
  install.packages("dplyr")
  require(dplyr)
}

if(!require(magrittr)){
  install.packages("magrittr")
  require(magrittr)
}

if(!require(tidyr)){
  install.packages("tidyr")
  require(tidyr)
}

if(!require(ggplot2)){
  install.packages("ggplot2")
  require(ggplot2)
}

if(!require(cowplot)){
  install.packages("cowplot")
  require(cowplot)
}

if(!require(paneljudge)){
  install.packages("paneljudge")
  require(paneljudge)
}

if(!require(vegan)){
  install.packages("vegan")
  require(vegan)
}

if(!require(parallel)){
  install.packages("parallel")
  require(parallel)
}

if(!require(ape)){
  install.packages("ape")
  require(ape)
}

if(!require(pegas)){
  install.packages("pegasn")
  require(pegas)
}

if(!require(RColorBrewer)){
  install.packages("RColorBrewer")
  require(RColorBrewer)
}


if(!require(GADMTools)){
  install.packages('GADMTools')
  require(GADMTools)
}


if(!require(Hmisc)){
  install.packages('Hmisc')
  require(Hmisc)
}
```

As we mentioned earlier, this tutorial start with .tsv table in CIGAR
format that has been generated with a previous pipeline created in the
lab. The output of this pipeline has the following structure:

$\begin{array}{c|c:c:c:c:c:c} \text{sampleID}&Gene_1,Allele_1&Gene_1,Allele_2&...&Gene_1,Allele_k&... & Gene_m, Allele_{k_m}\\ \hline ID_1 & \text{Read counts} &&& \\ \hdashline ... &&&&\\ \hdashline ID_n &&&& \end{array}$

Where the $Allele$ is coded in CIGAR format, typing "." for the
reference allele, $[0-9]*[A,T,C,G]$ for each point mutation observed,
and $[0-9]*[D,I]=[A,T,C,G]*$ for indels (Insertion and Deletions).

These CIGAR tables are stored in the server of the lab using the
following path structure:

`"STUDYNAME/RUNNAME/dada2/run_dada2/CIGARVariants.out.tsv"`

As this structure is maintained across all studies in the lab, we have
created a function called `fx_read_cigar_tables` that only requires two
arguments: `paths` (name of the folder of the study or the `STUDYNAME`),
and `sample_id_pattern` (a pattern string in the IDs of the samples that
differentiate them from controls). For this particular example, the path
will be `"colombia/"` , while the pattern will be `"SP"`.

```{r 'Uploading data sets'}

source("fx_read_cigar_tables.R")
cigar_object = fx_read_cigar_tables(paths = "colombia/", sample_id_pattern = "SP")

```

This function generates a list containing two data.frames, 1) a
`cigar_table`, where genotyping information is stored in cigar format;
and 2) a `metadata` table with 3 variables (columns), `samples` which
contains samples Id's, `run` which contains the run number (useful for
comparing performance across batches of samples), and `typeofSamp` which
differentiates between controls and samples of interest. In order to
view these tables use `View(cigar_table$cigar_table)` or
`View(cigar_table$metadata)` in the console.

## 2. Adding Metadata

Metadata would come from different sources, sometimes the sample ID
incorporates metadata in their coding system, other times metadata can
be stored in a different table, having one column specifying the sample
ID. In the case of the Colombian data set, we will perform the analysis
at the level of Municipality and in intervals of three months starting
from the first day of collection of samples. The information of sampling
location of the samples is incorporated in the `sample_id code`, while
the time of collection is in a separate table. Thus for sampling
location all codes starting with **"SP0101254"** come from
**"Buenaventura"**, samples starting with **"SP0112286"** come from
**"Quibdo"**, and samples starting with **"SP0126288"** come from
**"Guapi"**. In this data set, there is one sample that has an spelling
error in its code, the code is `"SP001254204"`, and we are going to
replace it with `"SP012542004"`. Then, to define sampling location we
are going to create a new variable in our `metadata` table called
`Population` using the function `mutate`.

```{r 'Adding Population'}

# Correcting sample "SP001254204"----
cigar_object[["metadata"]][cigar_object[["metadata"]][["samples"]] == "SP001254204",][["samples"]] = "SP0101254204"
rownames(cigar_object$cigar_table) = cigar_object[["metadata"]][["samples"]]

# Adding Population data----

cigar_object[["metadata"]] %<>% mutate(Population = case_when(
  grepl('SP0101254',samples) ~ 'Buenaventura',
  grepl('SP0112286',samples) ~ 'Quibdo',
  grepl('SP0126288',samples) ~ 'Guapi'
))
```

Moreover, there are some artifacts that `dada2` pipeline doesn't resolve
well like the generation of chimeras (artificial fusion of two different
haplotypes during the PCR amplification) in polyclonal samples. That is
the case of the alleles `PF3D7_1302900,1G` and `PF3D7_0612900,215A` that
are observed in polyclonal infections only. So we are going to proceed
to remove both alleles from our `cigar_table`. Additionally, `PvDHFR`
locus was amplified in order to detect mixed infections with *Plasmodium
vivax*, so we are going to remove this locus too.

```{r 'Removing artifacts and Pvivax control locus'}

# removing allele PF3D7_1302900,1G----
# this polymorphism is always present as a minor allele in polygenomic samples, increasing the proportion of polygenomic infections to up to 27%

cigar_object[["cigar_table"]] = cigar_object[["cigar_table"]][,!grepl("PF3D7_1302900,1G", colnames(cigar_object[["cigar_table"]]))]
cigar_object[["cigar_table"]] = cigar_object[["cigar_table"]][,!grepl("PF3D7_0612900,215A", colnames(cigar_object[["cigar_table"]]))]


# removing locus PvDHFR----
# this loci belongs to P. vivax

cigar_object[["cigar_table"]] = cigar_object[["cigar_table"]][,!grepl("PvDHFR", colnames(cigar_object[["cigar_table"]]))]

```

Then we will upload a metadata table from an external source. For this
purpose we are going to import the file called `metadata.csv` into our R
environment. From this table we want to extract the date of beginning of
symptoms (`date_of_symp`) to include it in our analysis. Unfortunately,
not all sampled individuals has answered that question in the survey,
for that reason we are going to impute that information using the date
of collection of the sample. Then, we are going to collapse information
at the level of month (`month_of_symp`), and we are going to merge our
current `metadata` with the `metadata` from the external source.
Finally, we are going to impute missing month dates using the month date
from a sample located one row above (sample collected just before the
sample with missing information).

```{r 'Adding collection data'}

external_metadata = read.csv("metadata.csv")

external_metadata %<>% mutate(
  samples = Código,
  Population = case_when(
  grepl('SP0101254',samples) ~ 'Buenaventura',
  grepl('SP0112286',samples) ~ 'Quibdo',
  grepl('SP0126288',samples) ~ 'Guapi'),
  date_of_symp = X2.9..Fecha.inicio.de.síntomas,
  date_of_collection = X2.3..Fecha.de.reclutamiento.
 )

external_metadata %<>% select(samples, Population, date_of_collection, date_of_symp)
external_metadata %<>% mutate(month_of_collection = substr(date_of_collection, 1, 7))


external_metadata[["group"]] = ifelse(external_metadata$samples %in% cigar_object$metadata$samples, "AMPseq", "noAMPseq")

# Merging metadata
cigar_object$metadata = merge(cigar_object$metadata, external_metadata[,c('samples', 'date_of_collection', 'date_of_symp', 'month_of_collection')], by = 'samples', all.x = TRUE)

# Imputing missing data with the previous observation
cigar_object$metadata[which(is.na(cigar_object$metadata$month_of_collection) & cigar_object$metadata$typeofSamp == 'Samples'),][['month_of_collection']] = cigar_object$metadata[which(is.na(cigar_object$metadata$month_of_collection) & cigar_object$metadata$typeofSamp == 'Samples') - 1,][['month_of_collection']]

cigar_object$metadata[which(is.na(cigar_object$metadata$date_of_collection) & cigar_object$metadata$typeofSamp == 'Samples'),][['date_of_collection']] = cigar_object$metadata[which(is.na(cigar_object$metadata$date_of_collection) & cigar_object$metadata$typeofSamp == 'Samples') - 1,][['date_of_collection']]

# Grouping data by quarters---

cigar_object$metadata$quarter_of_collection = paste(substr(cigar_object$metadata$date_of_collection, 1,4), quarters(as.Date(cigar_object$metadata$date_of_collection)), sep = "-")

```

```{r 'Ploting the number of collected samples by Municipality over time', echo=FALSE}
dates = c(paste(rep(2020, 4),c(paste0("0",8:9),10:12), sep ="-"),
          paste(rep(2021, 12),c(paste0("0",1:9),10:12), sep ="-"),
          paste(rep(2022, 2),c(paste0("0",1:2)), sep ="-"))

plot_temporal_collection_of_samples = external_metadata %>%
  filter(!is.na(Population)) %>%
  group_by(Population, month_of_collection) %>%
  summarise(nsamples= n())%>%
  ggplot(aes(x = month_of_collection, y = nsamples, fill = factor(Population,
                                                              levels = c("Quibdo",
                                                                         "Buenaventura",
                                                                         "Guapi"))))+
  geom_col()+
  theme_bw()+
  scale_fill_manual(values = c("firebrick3", "dodgerblue3", "gold3"))+
  facet_wrap(.~factor(Population,
                      levels = c("Quibdo",
                                 "Buenaventura",
                                 "Guapi")),
             strip.position = "top", ncol = 1)+
  labs(y = "Collected samples by PCD",
       x = "Months")+
  theme(axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 315, vjust = 0),
        axis.title = element_text(size = 12),
        strip.text = element_text(size = 12),
        legend.position =  "none")+
  scale_alpha_manual(values = c(1,.6))+
  scale_x_discrete(limits = dates)

```

```{r 'Map of study sites', echo=FALSE}

# Step 1: Get all shape files from LAC countries at national level
# SpatialPolygonsDataFrame at country level (level = 0)


col0.spldf <- gadm_sp_loadCountries("COL",level = 0, basefile = "./GADMTools/world.rds.files/rds0/")

col2.spldf <- gadm_sp_loadCountries("COL",level = 2, basefile = "./GADMTools/world.rds.files/rds2/")


localities = data.frame(Localities = factor(c("Guapí",
                                              "Buenaventura",
                                              "Quibdó"), levels = c("Guapí",
                                                                    "Buenaventura",
                                                                    "Quibdó")),
                        long = -70,
                        lat = c(10, 12, 14),
                        colors = c("gold3",
                                   "dodgerblue3",
                                   "firebrick3"))

# Step 3: plot the map


## Polygon dot plot of observed G6PDd frequency by LAC country----
plot_study_sites = ggplot() +
  geom_polygon(data=col0.spldf$spdf, aes(x=long, y=lat, group = group), fill = "floralwhite", color = "gray40", size=.3) +
  geom_polygon(data=col2.spldf[["spdf"]][col2.spldf[["spdf"]][["NAME_2"]] == "Quibdó",], aes(x=long, y=lat, group = group), fill = "firebrick3", color = "gray40", size=.3) +
  geom_polygon(data=col2.spldf[["spdf"]][col2.spldf[["spdf"]][["NAME_2"]] == "Buenaventura",], aes(x=long, y=lat, group = group), fill = "dodgerblue3", color = "gray40", size=.3) +
  geom_polygon(data=col2.spldf[["spdf"]][col2.spldf[["spdf"]][["NAME_2"]] == "Guapí",], aes(x=long, y=lat, group = group), fill = "gold3", color = "gray40", size=.3) +
  geom_point(data=localities, aes(x=long, y=lat, color=Localities), size = 5) +
  geom_label(data=localities, aes(x=long + c(1.3, 2.3, 1.5), y=lat, label = Localities)) +
  theme_bw()+
  labs(title = "Study sites in Colombia",
       x = "Longitude",
       y = "Latitude")+
  scale_x_continuous(limits = c(-80, -65))+
  scale_y_continuous(limits = c(-5, 15))+
  scale_color_manual(values = localities$colors)+
  theme(legend.position = "none",
        text = element_text(size = 10),
        axis.text = element_text(size = 10),
        title = element_text(size = 10))+
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 12))

```

```{r 'Plot of number of collected samples by Municipality over time whit map', echo=FALSE, warning=FALSE, message=FALSE, fig.width=10, fig.height=5, fig.cap='Figure 1: Number of collected samples by Municipality over time'}
plot_study_areas = ggdraw()+
  draw_plot(plot_study_sites,
            x = 0,
            y = 0,
            width = .5,
            height = 1)+
  draw_plot(plot_temporal_collection_of_samples,
            x = .5,
            y = 0,
            width = .5,
            height = 1)

# ggsave("plot_study_areas.png",
#        plot_study_areas,
#        device = "png",
#        units = "in",
#        width = 10,
#        height = 5,
#        dpi = 320)

plot_study_areas
```

\<p style="font-size:8pt; font-style:italic"\>\*\*Figure 1:\*\* Number
of collected samples by Municipality over time.\</p\>

## 3. Performance of the genotyping process

A first step in analyzing the genotypic data is to measure the
performance of the genotyping process in terms of the proportion of
samples amplified by each locus (amplification rate by locus) and the
proportion of loci amplified per each sample (amplification rate per
sample). In order to perform that task, we are going to convert our
cigar_table to a more manageable format called loci_abd format, where
amplicons or genes are going to be in columns, samples in rows, and the
allele in cigar format is going to be in each cell of the matrix
together with the read count of that allele in the sample.

$\begin{array}{c|c:c:c:c} \text{sampleID}&Gene_1&Gene_2&...& Gene_m\\ \hline ID_1 & Allele_{i_{i \in Alleles_{Gene_1}}}\text{:Read count} &&& \\ \hdashline ... &&&&\\ \hdashline ID_n &&&& \end{array}$

For that purpose we are going to use the function `fx_cigar2loci_abd.R`.
This function requires 4 arguments. First a `cigar_object` (containing
the cigar_table and the metadata). Then `markers`, which is a table with
the set of markers and their names (in a column named `amplicon`). This
argument is optional, and in case is `NULL`, the name of the amplicons
will be extracted from the columns in the `cigar_object`, but
information regarding chormosome location and length of the amplicon
will be missing. The next arguments are `min_abd` and `min_ratio`, which
are the minimum abundance (minimum read count) required to call an
allele and the minimum ratio between the minor and major alleles in a
polyclonal sample. By default these two arguments are 10 and 0.1
respectively. This function automatically differentiate between controls
and samples of interest, and its output is a `ampseq_object` list with 6
slots: `loci_abd_table` where the genotypic information of the samples
of interest is stored in a loci_abd format; the `metadata` of the
samples of interest; `controls` with all the information of the
controls; `markers` containing the information of the markers such as
the chromosome location; and two empty slots required for the next steps
which are `loci_performance` and `pop_summary`.

```{r "Generating a loci-abundance table"}
# (alleles and abundance will be in cells)

source("fx_cigar2loci_abd.R")

markers = read.csv("markers.csv")

ampseq = fx_cigar2loci_abd(cigar_object, markers = markers, min_abd = 10, min_ratio = .1)

```

### Amplification rate by locus

Once the data has been converted to the loci_abd format, we can use the
function `fx_loci_amplification_rate` to measure the proportion of
samples that have been amplified by each amplicon marker. This function
requires two arguments, the `ampseq_object` and `threshold`, which
defines the minimum proportion of samples that a marker should amplify
in order to be keep it for further analysis (default 0.65). All markers
below this `threshold` will be discarded.

```{r 'Filtering loci of low amplification rate'}

source("fx_loci_amplification_rate.R")

ampseq = fx_loci_amplification_rate(ampseq, threshold = .65)

```

Thus in this data set `r ncol(ampseq$loci_abd_table)` loci had an
amplification rate above .65, and
`r ncol(ampseq$discarded_loci$loci_abd_table)` loci were discarded. All
discarded loci are stored in the slot `discarded_loci` within the
`ampseq_object`. The discarded loci were:
`r paste(colnames(ampseq$discarded_loci$loci_abd_table), collapse = ', ')`.

```{r 'Ploting loci performance'}
# Plot Amplification rate per loci ----

plot_locus_amplificatin_rate = ggdraw()+
  draw_plot(ampseq$plots$amplification_rate_per_locus+
              theme(axis.text = element_text(size = 12),
                    axis.title = element_text(size = 12),
                    legend.text = element_text(size = 12)),
            x = 0,
            y = 0,
            width = 1,
            height = .5)+
  draw_plot(ampseq$plots$all_loci_amplification_rate+
              theme(axis.text = element_text(size = 12),
                    axis.title = element_text(size = 12)),
            x = 0,
            y = .5,
            width = 1,
            height = .5)

plot_locus_amplificatin_rate

# ggsave("plot_locus_amplificatin_rate.png",
#        plot_locus_amplificatin_rate,
#        device = "png",
#        units = "in",
#        width = 7,
#        height = 7,
#        dpi = 320)
```

\<p style="font-size:8pt; font-style:italic"\>\*\*Figure 2:\*\*
Proportion of amplified samples per locus. Top figure shows the
distribution of the amplification rate (or proportion of amplified
samples) of loci, with the number of loci in the y-axis and the
amplification rate in the x-axis. Bottom figure shows the the chromosome
location of each locus (chromosomes in y-axis and position in the
x-axis) and the gradient color represents its amplification rate.\</p\>

### Amplification rate by sample

The next step is to measure the proportion of loci amplified per each
sample, also called the amplification rate of the samples. For that
purpose we are going to use the function `fx_sample_amplification_rate`
that also requires only two arguments, the `ampseq_object` and a
`threshold`, which is the minimum proportion of loci that a sample
should amplified (by default 0.8).

```{r 'Filtering samples of low amplification rate'}
source("fx_sample_amplification_rate.R")

ampseq = fx_sample_amplification_rate(ampseq)

ampseq$plots$samples_amplification_rate+
         theme(axis.text = element_text(size = 12),
               axis.title = element_text(size = 12))
# ggsave("plot_sample_amplificatin_rate.png",
#        ampseq$plots$samples_amplification_rate+
#          theme(axis.text = element_text(size = 12),
#                axis.title = element_text(size = 12)),
#        device = "png",
#        units = "in",
#        width = 7,
#        height = 3.5,
#        dpi = 320)
```

\<p style="font-size:8pt; font-style:italic"\>\*\*Figure 3:\*\*
Proportion of amplified loci per sample. The figure shows the
distribution of the amplification rate (or proportion of amplified loci)
of the samples, with the number of samples in the y-axis and the
amplification rate in the x-axis.\</p\>

## 4. Molecular surveillance of drug resistance

Surveillance of polymorphisms or allelic variants associated with
resistance against antimalarials is of the utmost importance in public
health. That is why our panel of markers includes 5 genes (9 markers in
total, some genes are genotyped by more than one marker) that have
polymorphisms associated with antimalarial resistance. In this section
we will identify the different haplotypes of these genes present in our
data set, and we will determine the frequency of each haplotype in each
study area and in each quarter of the year. For this we will use the
function `fx_drug_resistant_haplotypes` which has 7 arguments. The first
argument is the `ampseq_object`. The second is a table with the
reference alleles for each gene, and the polymorphisms associated with
resistance. The structure of this table is as follows:

$$\begin{array}{c|c:c:c} \text{Chromosome} & \text{Gene_ID} & \text{Description} & \text{Mutation} & \text{Anotation} \\ \text{Pf3D7_04_v3} & \text{PF3D7_0417200} & dhfr & \text{N51I} & \text{Pyrimethamine resistance} \\ ... \end{array}$$

Where the mutation describes the reference amino acid (sensitive to the
drug), the position in the amino acid chain, and finally the amino acid
associated with resistance.

The third and fourth arguments refer to the common name of the gene (or
the name by which it is identified in the `markers` table in the
`ampseq_object`) and the gene ID in the gff file of the referential
strain (in this case strain 3D7). The fifth and sixth arguments are the
.gff and .fasta files of the genome of the reference strain, and the
last argument, `variables`, is a vector that has the columns of the
`metadata` table that will be used to define the subpopulations and
generate the report graph. For this particular example we will define as
`variables = c('samples', 'Population', 'quarter_of_collection')`, where
`samples`, is the column that we will use to map the data, `Population`
is the column to define the area of study, and `quarter_of_collection`
defines the time scale.

The function generates a list with 3 tables and a graph. The first table
contains the haplotypes found in each sample (rows) for each gene
(columns). Each number in the haplotype indicates a position in the
amino acid chain, the letter before the number indicates the reference
allele (with sensitive phenotype), and the letter after the number is
the allele observed in the sample. If the letters are in capital
letters, that allele in that position has been previously reported as
resistant, whereas the letters in lower case indicate that it is the
first time that said position has been reported as polymorphic. In case
the sample is polyclonal, each allele observed is separated by the
following symbol `|`, and the order in which they are reported is based
on their read count. Null data, that is, sections of the gene that have
not been amplified, are completed with the question mark `?`.

The second table contains the inferred phenotype for each sample (rows)
for each gene (columns). The third table contains the count of each
haplotype in the population (number of times observed) and its frequency
in the subpopulation (defined based on geographic and temporal
information). It is important to note that polyclonal samples are
included in this calculation, so the sum of frequencies may be greater
than unity in some cases.

```{r 'Molecular surveillance of drug resistance'}
source('fx_drug_resistant_haplotypes.R')

drug_resistant_haplotypes = fx_drug_resistant_haplotypes(ampseq,
                                                         reference_alleles = 'drugR_alleles.csv',
                                        gene_names = c('PfDHFR',
                                                       'PfMDR1',
                                                       'PfDHPS',
                                                       'PfKelch13',
                                                       'PF3D7_1447900'),
                                        gene_ids = c('PF3D7_0417200',
                                                     'PF3D7_0523000',
                                                     'PF3D7_0810800',
                                                     'PF3D7_1343700',
                                                     'PF3D7_1447900'),
                                        gff_file = "reference/3D7/PlasmoDB-59_Pfalciparum3D7.gff",
                                        fasta_file = "reference/3D7/PlasmoDB-59_Pfalciparum3D7_Genome.fasta",
                                        variables = c('samples', 'Population', 'quarter_of_collection'))

blues = brewer.pal(9, 'Blues')
reds = brewer.pal(9, 'Reds')

drug_resistant_haplotypes$haplo_freq_plot+
  scale_fill_manual(values = c(
    blues[c(3, 8)], reds[3], # MDR2
    reds[c(8,5,3)], blues[c(8,3)], # DFHR
    blues[c(2, 4, 3, 8)], reds[8], # DHPS
    blues[8], #K13
    blues[c(2,3)], reds[c(5,3,8)] # MDR1
  ))


```

\<p style="font-size:8pt; font-style:italic"\>\*\*Figure 4:\*\*
Frequency of haplotypes of genes associated with drug resistance. y-axis
shows the frequency in the sub-population, x-axis shows the quarter of
the year where the sample was collected, rows panels corresponds to the
three study areas, and column panels represents each genotyped gene.
Colors were assigned based on the possible phenotype, dark blue
indicates sensitive, while dark red indicates resistance. Light colors
where assigned for incomplete information.\</p\>

## 5. Measuring geographic connectivity

Malaria transmission is heterogeneous throughout the Colombian
territory, and it is mainly concentrated in transmission foci where
demographic and environmental factors favor the interaction between the
two hosts of the parasite, humans and Anopheles mosquitoes.
Operationally, disease control units are defined based on sub-national
administrative divisions. The connectivity or dispersal pattern of the
parasite between these geographic units may limit progress in disease
control if activities are not properly coordinated. This connectivity is
mainly influenced by human movement, and can be inferred by estimating
the proportion of genetically closely related parasites between the
different areas.

In this section we will measure the pairwise genetic relatedness between
samples, and calculate the proportion of pairwise comparisons that have
a relatedness $\ge 0.9$ within and between operational units. For that
we are going to use the following functions: 1) `fx_ampseq2loci` to
convert the `loci_abd` table into a `loci` table that only contains the
allele information (read abundance is removed), 2) `fx_get_relatedness`
that compute pairwise genetic relatedness using the HMMIBD algorithm
implemented in panlejugde, 3) `fx_plot_network` to create a network
representation of the pairwise relatedness information, 4)
`fx_plot_relatedness_distribution` to visualize the distribution of
pairwise relatedness across the different locations, and 5)
`fx_frac_highly_related` to visualize the fraction of highly related
haplotypes within and between study areas.

```{r 'generating the loci_object'}
# generating the loci_object----
source("fx_ampseq2loci.R")
loci_object = fx_ampseq2loci(ampseq)
```

```{r 'Estimating relatedness'}
# measuring relatedness----
source("fx_get_relatedness.R")

if(file.exists('pairwise_relatedness.csv')){
  pairwise_relatedness = as.matrix(read.csv('pairwise_relatedness.csv', row.names = 'X'))
}else{
  pairwise_relatedness = fx_pairwise_relatedness(loci_object)
  write.csv(pairwise_relatedness, 'pairwise_relatedness.csv')
}

```

```{r 'network'}

source('fx_plot_network.R')

plot_network = fx_plot_network(relatedness_matrix = pairwise_relatedness,
                               threshold = .99,
                               metadata = ampseq$metadata,
                               sample_id = 'samples',
                               group_by = 'Population',
                               levels = c("Quibdo", "Buenaventura", "Guapi"),
                               colors = c("firebrick3", "dodgerblue3", "gold3")
                              )

```

\<p style="font-size:8pt; font-style:italic"\>\*\*Figure 5:\*\* Network
representation of pairwise genetic relatedness between samples. Each
node represents a sample, and branches are displayed only for pairwise
comparisons with a relatedness greater than 0.99. Colors were assigned
based on the sampling location: Buenaventura (blue), Guapi (glold) and
Quibdo (red).\</p\>

```{r 'relatedness distribution'}

source('fx_plot_relatedness_distribution.R')

plot_relatedness_distribution = fx_plot_relatedness_distribution(
  relatedness_matrix = pairwise_relatedness,
  metadata = ampseq$metadata,
  Population = 'Population',
  fill_color = c("firebrick3", "gold3", "dodgerblue3", "gray50", "gray50", "gray50")
)
```

```{r 'highly related '}
source("fx_frac_highly_related.R")

plot_frac_highly_related = fx_plot_frac_highly_related(
  relatedness_matrix = pairwise_relatedness,
  metadata = ampseq$metadata,
  Population = 'Population',
  fill_color = c("dodgerblue3",  "firebrick3", "gold3", "gray50", "gray50", "gray50"),
  threshold = 0.99)

```

```{r 'Connectivity'}

plot_connectivity = ggdraw()+
  draw_plot(plot_relatedness_distribution,
            x = 0,
            y = 0,
            width = .7,
            height = 1)+
  draw_plot(plot_frac_highly_related,
            x = 0.7,
            y = 0,
            width = .3,
            height = 1)

plot_connectivity

```

\<p style="font-size:8pt; font-style:italic"\>\*\*Figure 6:\*\* Left
figure shows the distribution of pairwise genetic relatedness within and
between sampling locations. Right figures shows the proportion of highly
related samples within and between sampling locations.\</p\>

## 6. Monitoring transmission intensity

### Complexity of infection and Genetic diversity by locus

```{r "Defining clonality of the samples"}

source("fx_get_polygenomic.R")
ampseq = fx_get_polygenomic(ampseq_object = ampseq, strata = "Population")

```

```{r 'getting genetic diversity by loci'}

source("fx_loci_diversity.R")

ampseq$loci_performance = cbind(ampseq$loci_performance,fx_loci_diversity(ampseq$loci_abd_table, variance = TRUE))
```

### 6.1 Complexity of infection and transmission

```{r 'Proportion of polyclonal infections by sampling location'}

plot_poly_by_pop = ampseq[["pop_summary"]] %>% ggplot(aes(x = factor(pop, levels = c("Quibdo", "Buenaventura", "Guapi", "Total")),
                                                          y = prop_poly,
                                                          fill = factor(pop, levels = c("Quibdo", "Buenaventura", "Guapi", "Total"))))+
  geom_col(alpha = .6) +
  geom_errorbar(aes(ymin = prop_poly_lower, ymax = prop_poly_upper), width = .2)+
  theme_bw() +
  labs(title = "Frequency of polyclonal infections",
       y = "Frecuencia") +
  scale_size(range = c(3, 6)) +
  scale_fill_manual(values = c("firebrick3", "dodgerblue3", "gold3", "gray30"))+
  scale_y_continuous(limits = c(0, 0.3))+
  theme(axis.text = element_text(size = 12),
        axis.title = element_blank(),
        legend.position = "none")




```

```{r 'Distribution of COI by sampling location'}

source("log_scale_histogram.R")

plot_log_coi_by_pop = log_scale_histogram(data = ampseq$metadata,
                                          var = "coi",
                                          binwidth = 1,
                                          group_by = "Population",
                                          levels = c("Quibdo", "Buenaventura", "Guapi"), x_label = "COI",
                                          fill_color = c("firebrick3", "dodgerblue3", "gold3"),
                                          y_breaks = c(1, 10, 100, 400), ncol = 3)+
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 12),
        strip.text = element_text(size = 12)) +
  labs(y = "# Samples")
```

```{r 'Distribution of the number of heterozygous loci per sample by sampling location'}
plot_log_NPolyLoci_by_pop = log_scale_histogram(data = ampseq$metadata[ampseq$metadata$NPolyLoci != 0,],
                                                var = "NPolyLoci", binwidth = 1, group_by = "Population",
                                                levels = c("Quibdo", "Buenaventura", "Guapi"), x_label = "Number of heterozygous loci per sample",
                                                fill_color = c("firebrick3", "dodgerblue3", "gold3", "gray70"),
                                                y_breaks = c(1, 5,10, 30), ncol = 3)+
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 12),
        strip.text = element_text(size = 12)) +
  labs(y = "# Samples",
       x = "# heterozygous loci per sample")

```

```{r 'Temporal cahnge of complexity of infection'}

ampseq$metadata %<>% mutate(Pop_quarter = paste(Population, quarter_of_collection, sep = '_'))

plot_poly_by_pop_over_time = fx_get_polygenomic(ampseq_object = ampseq, strata = "Pop_quarter", update_popsummary = F)[-1,]%>%mutate(
  Population = stringr::str_split(pop, '_', simplify = TRUE)[,1],
  Date = stringr::str_split(pop, '_', simplify = TRUE)[,2]
  )%>%
  ggplot(aes(x = Date,
             y = prop_poly,
             ymin = prop_poly_lower,
             ymax = prop_poly_upper,
             fill = Population))+
  geom_col()+
  geom_errorbar(width = .2)+
  facet_wrap(~Population, ncol = 3)+
  theme_bw()+
  scale_fill_manual(values = c("dodgerblue3","gold3","firebrick3"))+
  labs(y = "Polyclonal infections",
       x = "Date of sampling")+
  theme(axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 315, vjust = 0),
        axis.title = element_text(size = 12),
        strip.text = element_text(size = 12),
        legend.position =  "none")
```

```{r 'Complexity of infection and transmission intensity'}
plot_log_poly_by_pop_map = ggdraw()+
  draw_plot(plot_study_sites,
            x = 0,
            y = .34,
            width = .5,
            height = .66)+
  draw_plot(plot_poly_by_pop,
            x = .5,
            y = .34,
            width = .5,
            height = .22)+
  draw_plot(plot_log_coi_by_pop,
            x = .5,
            y = .56,
            width = .5,
            height = .22)+
  draw_plot(plot_log_NPolyLoci_by_pop,
            x = .5,
            y = .88,
            width = .5,
            height = .22)+
  draw_plot(plot_poly_by_pop_over_time,
            x = 0,
            y = 0,
            width = 1,
            height = .33)

plot_log_poly_by_pop_map

# ggsave("plot_log_poly_by_pop_map.png",
#        plot_log_poly_by_pop_map,
#        device = "png",
#        units = "in",
#        width = 10,
#        height = 5,
#        dpi = 320)

```

### 6.2 Haplotypic and genetic diversity and transmission

```{r 'getting genetic diversity by pop'}

source("fx_pop_diversity.R")

ampseq[["pop_summary"]] = cbind(ampseq[["pop_summary"]],fx_pop_diversity(ampseq_object = ampseq, strata = "Population")[-1])

```

```{r 'Haplotype and genetic diversity by sampling location'}

plot_div_by_pop = ampseq[["pop_summary"]]%>%
  pivot_longer(cols= all_of(c("Effective.richness",
                              "Shannon",
                              "Hexp")),
               names_to = "metric", values_to = "value")%>%
  ggplot(aes(x = factor(pop, levels = c("Quibdo", "Buenaventura", "Guapi", "Total")),
             y = value,
             color = factor(pop, levels = c("Quibdo", "Buenaventura", "Guapi", "Total")),
             size = Richness))+
  geom_point(alpha = .6) +
  facet_wrap(~factor(metric,
                     levels = c("Effective.richness",
                                "Shannon",
                                "Hexp")),
             scales = "free_y",
             ncol = 1) +
  theme_bw() +
  scale_color_manual(values = c("firebrick3", "dodgerblue3", "gold3", "gray30"))+
  labs(title = "Haplotypic and genetic diversity",
       y = "Value",
       x = "Population",
       color = "Population")+
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 12),
        strip.text = element_text(size = 12))


plot_div_by_pop_map = ggdraw()+
  draw_plot(plot_study_sites,
            x = 0,
            y = .1,
            width = .4,
            height = .8)+
  draw_plot(plot_div_by_pop,
            x = .4,
            y = 0,
            width = .6,
            height = 1)

plot_div_by_pop_map

# ggsave("plot_div_by_pop_map.png",
#        plot_div_by_pop_map,
#        device = "png",
#        units = "in",
#        width = 12,
#        height = 6,
#        dpi = 320)
```

### 6.3 Relatedness and Transmission

```{r '3 months intervals'}
pairwise_relatednes_l$Pop_period_3months_comparisson

write.csv(pairwise_relatednes_l, "pairwise_relatednes_l.csv")
write.csv(pairwise_relatedness, "pairwise_relatednes_dist_matrix.csv")


poplevels = c(
  "Quibdo_Aug - Oct, 2020",
  "Quibdo_Nov, 2020 - Jan, 2021",
  "Quibdo_Feb - Apr, 2021",
  "Quibdo_May - Jul, 2021",
  "Quibdo_Aug - Oct, 2021",
  "Quibdo_Nov, 2021 - Feb, 2022",
  
"Buenaventura_Aug - Oct, 2020",
"Buenaventura_Nov, 2020 - Jan, 2021",
"Buenaventura_Feb - Apr, 2021",
"Buenaventura_May - Jul, 2021",
"Buenaventura_Aug - Oct, 2021",
"Buenaventura_Nov, 2021 - Feb, 2022",

"Guapi_Aug - Oct, 2020",
"Guapi_Nov, 2020 - Jan, 2021",
"Guapi_Feb - Apr, 2021",
"Guapi_May - Jul, 2021",
"Guapi_Aug - Oct, 2021",
"Guapi_Nov, 2021 - Feb, 2022"
)

dateslevels = c("Aug - Oct, 2020",
               "Nov, 2020 - Jan, 2021",
               "Feb - Apr, 2021",
               "May - Jul, 2021",
               "Aug - Oct, 2021",
               "Nov, 2021 - Feb, 2022")


popcolors = c(brewer.pal(6,"Reds"),
              brewer.pal(5,"Blues"),
              brewer.pal(7,"YlGn"))

pairwise_relatednes_l %>%
  group_by(Pop_period_3months_comparisson) %>% 
  dplyr::summarise(freq = sum(r>=.99),
                   n = n()) %>% group_by(Pop_period_3months_comparisson)%>%
  mutate(prop = binconf(freq,
                        n,
                        alpha = 0.05,
                        method = "exact")[1],
         lower = binconf(freq,
                         n,
                         alpha = 0.05,
                         method = "exact")[2],
         upper = binconf(freq,
                         n,
                         alpha = 0.05,
                         method = "exact")[3])%>%
  filter(Pop_period_3months_comparisson %in% poplevels)%>%
  mutate(Pop_comparisson = gsub("_.+","",Pop_period_3months_comparisson),
         Dates = gsub(".+_","",Pop_period_3months_comparisson))%>%
  ggplot(aes(x = factor(Dates, levels = dateslevels),
             y = prop, fill = factor(Pop_period_3months_comparisson, levels = poplevels
             ))) + 
  geom_col(alpha = .85)+
  geom_errorbar(aes(ymin = lower, ymax = upper), width = .2)+
  scale_fill_manual(values = popcolors)+
  theme_bw()+
  labs(y = "Fraccion de pares de muestras\naltamente relacionadas (IBD > 0.99)")+
  theme(axis.text = element_text(size = 12),
        axis.text.x = element_text(angle = 315, vjust = 0),
        axis.title.y = element_text(size = 12),
        axis.title.x = element_blank(),
        strip.text = element_text(size = 12),
        legend.position = "none")+
  facet_wrap(~factor(Pop_comparisson, levels = c("Quibdo",
                                                 "Buenaventura",
                                                 "Guapi")), ncol = 1)


```
